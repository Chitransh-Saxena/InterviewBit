Binary Exponentiation

-> Exponentiation by doubling
-> Recursive
-> Iterative
-> When is it useful?


So, what is Binary Exponentiation
    -> It is calculating value of the exponents by doubling.
    -> So, if we want to calculate 3^8 -> Traditionally, we would do 3*3*3 .... 3 (3 multiplied by itself, 8 times)
    -> Now, if this number increases to 100s or 1000s of digits, we would run out of memory as well as the complexity of program would increase by a lot.
    -> Without even studying Binary Exponentiation, we can do some optimization based on some properties of exponents.
        -> Like, we know 3^2 * 3^2 = 3^4
        -> So, we can use this property to calculate the even exponents.
    -> Similarly, for odd numbers we could do some tweaking and get some results.
    -> Now, let's see what is Binary Exponentiation about.



How does Binary Exponentiation work?

-> Let's say we need to find what is 3^25.
-> Split 25 into binary = 16 + 8 + 1 = 11001
    -> 3^25 = 3^16 * 3^8 * 3^1
-> Now, we will initialize 2 variables (num = 3^1 and ans = 1)
-> This is how the calculations are going to go
    -> We start from most significant bit (right most)
    -> If the bit is set (1), then we multiply num by itself and calculate ans.
        -> ans = ans * num
        -> num = num * num
    -> Else
        -> num = num * num.

    -> So, basically, if the bit is set, we mulitply `num * ans`

-> Dry-running this on 3^25
    -> Power = 25 = 16 + 8 + 1 = 11001
    -> Init
        -> num = 3^1
        -> ans = 1
    -> First bit (1)
        -> ans = ans * num = 3^1
        -> num = num * num = 3^2
    -> Second bit (0)
        -> num = num * num = 3^4
    -> Third bit (0)
        -> num = 3^8
    -> Fourth bit (1)
        -> ans = ans * num = 3^1 * 3^8 = 3^9
        -> num = 3^16
    -> Fifth bit (1)
        -> ans = num * ans = 3^9 * 3^16 = 3^25
        -> num .. doesn't matter because this is last bit
    
    -> So, finally we have ans = 3^25.

-> Time complexity of this approach
    -> O(LogN)
    -> How?
        -> Too complicated

############### CODE #############
Recursive Solution

int power(int a, int b) {           // a = 3, b = 25

if(b == 0) {
    return 1;       // Any number raised to power 0 = 1
}

int x = power(a, b/2);

if(b%2 == 0) {
    return x*x;
}
else {
    return a * x * x;
}

}